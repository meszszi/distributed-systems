# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.2
#
# <auto-generated>
#
# Generated from file `Accounts.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module Accounts
_M_Accounts = Ice.openModule('Accounts')
__name__ = 'Accounts'

if 'Currency' not in _M_Accounts.__dict__:
    _M_Accounts.Currency = Ice.createTempClass()
    class Currency(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Currency.GBP = Currency("GBP", 1)
    Currency.EUR = Currency("EUR", 2)
    Currency.CHF = Currency("CHF", 3)
    Currency.USD = Currency("USD", 4)
    Currency.PLN = Currency("PLN", 5)
    Currency._enumerators = { 1:Currency.GBP, 2:Currency.EUR, 3:Currency.CHF, 4:Currency.USD, 5:Currency.PLN }

    _M_Accounts._t_Currency = IcePy.defineEnum('::Accounts::Currency', Currency, (), Currency._enumerators)

    _M_Accounts.Currency = Currency
    del Currency

if 'AccountType' not in _M_Accounts.__dict__:
    _M_Accounts.AccountType = Ice.createTempClass()
    class AccountType(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    AccountType.STANDARD = AccountType("STANDARD", 1)
    AccountType.PREMIUM = AccountType("PREMIUM", 2)
    AccountType._enumerators = { 1:AccountType.STANDARD, 2:AccountType.PREMIUM }

    _M_Accounts._t_AccountType = IcePy.defineEnum('::Accounts::AccountType', AccountType, (), AccountType._enumerators)

    _M_Accounts.AccountType = AccountType
    del AccountType

if 'GenericException' not in _M_Accounts.__dict__:
    _M_Accounts.GenericException = Ice.createTempClass()
    class GenericException(Ice.UserException):
        def __init__(self, message=''):
            self.message = message

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Accounts::GenericException'

    _M_Accounts._t_GenericException = IcePy.defineException('::Accounts::GenericException', GenericException, (), False, None, (('message', (), IcePy._t_string, False, 0),))
    GenericException._ice_type = _M_Accounts._t_GenericException

    _M_Accounts.GenericException = GenericException
    del GenericException

if 'AuthenticationFailedException' not in _M_Accounts.__dict__:
    _M_Accounts.AuthenticationFailedException = Ice.createTempClass()
    class AuthenticationFailedException(_M_Accounts.GenericException):
        def __init__(self, message=''):
            _M_Accounts.GenericException.__init__(self, message)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Accounts::AuthenticationFailedException'

    _M_Accounts._t_AuthenticationFailedException = IcePy.defineException('::Accounts::AuthenticationFailedException', AuthenticationFailedException, (), False, _M_Accounts._t_GenericException, ())
    AuthenticationFailedException._ice_type = _M_Accounts._t_AuthenticationFailedException

    _M_Accounts.AuthenticationFailedException = AuthenticationFailedException
    del AuthenticationFailedException

if 'IllegalCurrencyException' not in _M_Accounts.__dict__:
    _M_Accounts.IllegalCurrencyException = Ice.createTempClass()
    class IllegalCurrencyException(_M_Accounts.GenericException):
        def __init__(self, message=''):
            _M_Accounts.GenericException.__init__(self, message)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Accounts::IllegalCurrencyException'

    _M_Accounts._t_IllegalCurrencyException = IcePy.defineException('::Accounts::IllegalCurrencyException', IllegalCurrencyException, (), False, _M_Accounts._t_GenericException, ())
    IllegalCurrencyException._ice_type = _M_Accounts._t_IllegalCurrencyException

    _M_Accounts.IllegalCurrencyException = IllegalCurrencyException
    del IllegalCurrencyException

if 'PeselRegisteredException' not in _M_Accounts.__dict__:
    _M_Accounts.PeselRegisteredException = Ice.createTempClass()
    class PeselRegisteredException(_M_Accounts.GenericException):
        def __init__(self, message=''):
            _M_Accounts.GenericException.__init__(self, message)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Accounts::PeselRegisteredException'

    _M_Accounts._t_PeselRegisteredException = IcePy.defineException('::Accounts::PeselRegisteredException', PeselRegisteredException, (), False, _M_Accounts._t_GenericException, ())
    PeselRegisteredException._ice_type = _M_Accounts._t_PeselRegisteredException

    _M_Accounts.PeselRegisteredException = PeselRegisteredException
    del PeselRegisteredException

if 'InsufficientBalanceException' not in _M_Accounts.__dict__:
    _M_Accounts.InsufficientBalanceException = Ice.createTempClass()
    class InsufficientBalanceException(_M_Accounts.GenericException):
        def __init__(self, message=''):
            _M_Accounts.GenericException.__init__(self, message)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Accounts::InsufficientBalanceException'

    _M_Accounts._t_InsufficientBalanceException = IcePy.defineException('::Accounts::InsufficientBalanceException', InsufficientBalanceException, (), False, _M_Accounts._t_GenericException, ())
    InsufficientBalanceException._ice_type = _M_Accounts._t_InsufficientBalanceException

    _M_Accounts.InsufficientBalanceException = InsufficientBalanceException
    del InsufficientBalanceException

if '_t_AccountBalance' not in _M_Accounts.__dict__:
    _M_Accounts._t_AccountBalance = IcePy.defineDictionary('::Accounts::AccountBalance', (), _M_Accounts._t_Currency, IcePy._t_double)

if 'AccountDetails' not in _M_Accounts.__dict__:
    _M_Accounts.AccountDetails = Ice.createTempClass()
    class AccountDetails(object):
        def __init__(self, declaredMonthlyIncome=0.0, balance=None):
            self.declaredMonthlyIncome = declaredMonthlyIncome
            self.balance = balance

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Accounts.AccountDetails):
                return NotImplemented
            else:
                if self.declaredMonthlyIncome != other.declaredMonthlyIncome:
                    return False
                if self.balance != other.balance:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Accounts._t_AccountDetails)

        __repr__ = __str__

    _M_Accounts._t_AccountDetails = IcePy.defineStruct('::Accounts::AccountDetails', AccountDetails, (), (
        ('declaredMonthlyIncome', (), IcePy._t_double),
        ('balance', (), _M_Accounts._t_AccountBalance)
    ))

    _M_Accounts.AccountDetails = AccountDetails
    del AccountDetails

if 'CreditCosts' not in _M_Accounts.__dict__:
    _M_Accounts.CreditCosts = Ice.createTempClass()
    class CreditCosts(Ice.Value):
        def __init__(self, homeCurrency=0.0, foreignCurrency=Ice.Unset):
            self.homeCurrency = homeCurrency
            self.foreignCurrency = foreignCurrency

        def ice_id(self):
            return '::Accounts::CreditCosts'

        @staticmethod
        def ice_staticId():
            return '::Accounts::CreditCosts'

        def __str__(self):
            return IcePy.stringify(self, _M_Accounts._t_CreditCosts)

        __repr__ = __str__

    _M_Accounts._t_CreditCosts = IcePy.defineValue('::Accounts::CreditCosts', CreditCosts, -1, (), False, False, None, (
        ('homeCurrency', (), IcePy._t_double, False, 0),
        ('foreignCurrency', (), IcePy._t_double, True, 1)
    ))
    CreditCosts._ice_type = _M_Accounts._t_CreditCosts

    _M_Accounts.CreditCosts = CreditCosts
    del CreditCosts

_M_Accounts._t_AccountManager = IcePy.defineValue('::Accounts::AccountManager', Ice.Value, -1, (), False, True, None, ())

if 'AccountManagerPrx' not in _M_Accounts.__dict__:
    _M_Accounts.AccountManagerPrx = Ice.createTempClass()
    class AccountManagerPrx(Ice.ObjectPrx):

        def getAccountDetails(self, context=None):
            return _M_Accounts.AccountManager._op_getAccountDetails.invoke(self, ((), context))

        def getAccountDetailsAsync(self, context=None):
            return _M_Accounts.AccountManager._op_getAccountDetails.invokeAsync(self, ((), context))

        def begin_getAccountDetails(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Accounts.AccountManager._op_getAccountDetails.begin(self, ((), _response, _ex, _sent, context))

        def end_getAccountDetails(self, _r):
            return _M_Accounts.AccountManager._op_getAccountDetails.end(self, _r)

        def transferToAccount(self, currency, amount, context=None):
            return _M_Accounts.AccountManager._op_transferToAccount.invoke(self, ((currency, amount), context))

        def transferToAccountAsync(self, currency, amount, context=None):
            return _M_Accounts.AccountManager._op_transferToAccount.invokeAsync(self, ((currency, amount), context))

        def begin_transferToAccount(self, currency, amount, _response=None, _ex=None, _sent=None, context=None):
            return _M_Accounts.AccountManager._op_transferToAccount.begin(self, ((currency, amount), _response, _ex, _sent, context))

        def end_transferToAccount(self, _r):
            return _M_Accounts.AccountManager._op_transferToAccount.end(self, _r)

        def withdrawFromAccount(self, currency, amount, context=None):
            return _M_Accounts.AccountManager._op_withdrawFromAccount.invoke(self, ((currency, amount), context))

        def withdrawFromAccountAsync(self, currency, amount, context=None):
            return _M_Accounts.AccountManager._op_withdrawFromAccount.invokeAsync(self, ((currency, amount), context))

        def begin_withdrawFromAccount(self, currency, amount, _response=None, _ex=None, _sent=None, context=None):
            return _M_Accounts.AccountManager._op_withdrawFromAccount.begin(self, ((currency, amount), _response, _ex, _sent, context))

        def end_withdrawFromAccount(self, _r):
            return _M_Accounts.AccountManager._op_withdrawFromAccount.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Accounts.AccountManagerPrx.ice_checkedCast(proxy, '::Accounts::AccountManager', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Accounts.AccountManagerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Accounts::AccountManager'
    _M_Accounts._t_AccountManagerPrx = IcePy.defineProxy('::Accounts::AccountManager', AccountManagerPrx)

    _M_Accounts.AccountManagerPrx = AccountManagerPrx
    del AccountManagerPrx

    _M_Accounts.AccountManager = Ice.createTempClass()
    class AccountManager(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Accounts::AccountManager', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Accounts::AccountManager'

        @staticmethod
        def ice_staticId():
            return '::Accounts::AccountManager'

        def getAccountDetails(self, current=None):
            raise NotImplementedError("servant method 'getAccountDetails' not implemented")

        def transferToAccount(self, currency, amount, current=None):
            raise NotImplementedError("servant method 'transferToAccount' not implemented")

        def withdrawFromAccount(self, currency, amount, current=None):
            raise NotImplementedError("servant method 'withdrawFromAccount' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Accounts._t_AccountManagerDisp)

        __repr__ = __str__

    _M_Accounts._t_AccountManagerDisp = IcePy.defineClass('::Accounts::AccountManager', AccountManager, (), None, ())
    AccountManager._ice_type = _M_Accounts._t_AccountManagerDisp

    AccountManager._op_getAccountDetails = IcePy.Operation('getAccountDetails', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_Accounts._t_AccountDetails, False, 0), (_M_Accounts._t_AuthenticationFailedException,))
    AccountManager._op_transferToAccount = IcePy.Operation('transferToAccount', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Accounts._t_Currency, False, 0), ((), IcePy._t_double, False, 0)), (), None, (_M_Accounts._t_AuthenticationFailedException, _M_Accounts._t_IllegalCurrencyException))
    AccountManager._op_withdrawFromAccount = IcePy.Operation('withdrawFromAccount', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Accounts._t_Currency, False, 0), ((), IcePy._t_double, False, 0)), (), None, (_M_Accounts._t_AuthenticationFailedException, _M_Accounts._t_IllegalCurrencyException, _M_Accounts._t_InsufficientBalanceException))

    _M_Accounts.AccountManager = AccountManager
    del AccountManager

_M_Accounts._t_PremiumAccountManager = IcePy.defineValue('::Accounts::PremiumAccountManager', Ice.Value, -1, (), False, True, None, ())

if 'PremiumAccountManagerPrx' not in _M_Accounts.__dict__:
    _M_Accounts.PremiumAccountManagerPrx = Ice.createTempClass()
    class PremiumAccountManagerPrx(_M_Accounts.AccountManagerPrx):

        def getCreditCosts(self, currency, amount, monthsDuration, context=None):
            return _M_Accounts.PremiumAccountManager._op_getCreditCosts.invoke(self, ((currency, amount, monthsDuration), context))

        def getCreditCostsAsync(self, currency, amount, monthsDuration, context=None):
            return _M_Accounts.PremiumAccountManager._op_getCreditCosts.invokeAsync(self, ((currency, amount, monthsDuration), context))

        def begin_getCreditCosts(self, currency, amount, monthsDuration, _response=None, _ex=None, _sent=None, context=None):
            return _M_Accounts.PremiumAccountManager._op_getCreditCosts.begin(self, ((currency, amount, monthsDuration), _response, _ex, _sent, context))

        def end_getCreditCosts(self, _r):
            return _M_Accounts.PremiumAccountManager._op_getCreditCosts.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Accounts.PremiumAccountManagerPrx.ice_checkedCast(proxy, '::Accounts::PremiumAccountManager', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Accounts.PremiumAccountManagerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Accounts::PremiumAccountManager'
    _M_Accounts._t_PremiumAccountManagerPrx = IcePy.defineProxy('::Accounts::PremiumAccountManager', PremiumAccountManagerPrx)

    _M_Accounts.PremiumAccountManagerPrx = PremiumAccountManagerPrx
    del PremiumAccountManagerPrx

    _M_Accounts.PremiumAccountManager = Ice.createTempClass()
    class PremiumAccountManager(_M_Accounts.AccountManager):

        def ice_ids(self, current=None):
            return ('::Accounts::AccountManager', '::Accounts::PremiumAccountManager', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Accounts::PremiumAccountManager'

        @staticmethod
        def ice_staticId():
            return '::Accounts::PremiumAccountManager'

        def getCreditCosts(self, currency, amount, monthsDuration, current=None):
            raise NotImplementedError("servant method 'getCreditCosts' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Accounts._t_PremiumAccountManagerDisp)

        __repr__ = __str__

    _M_Accounts._t_PremiumAccountManagerDisp = IcePy.defineClass('::Accounts::PremiumAccountManager', PremiumAccountManager, (), None, (_M_Accounts._t_AccountManagerDisp,))
    PremiumAccountManager._ice_type = _M_Accounts._t_PremiumAccountManagerDisp

    PremiumAccountManager._op_getCreditCosts = IcePy.Operation('getCreditCosts', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Accounts._t_Currency, False, 0), ((), IcePy._t_double, False, 0), ((), IcePy._t_int, False, 0)), (), ((), _M_Accounts._t_CreditCosts, False, 0), (_M_Accounts._t_AuthenticationFailedException, _M_Accounts._t_IllegalCurrencyException))

    _M_Accounts.PremiumAccountManager = PremiumAccountManager
    del PremiumAccountManager

if 'RegistrationStatus' not in _M_Accounts.__dict__:
    _M_Accounts.RegistrationStatus = Ice.createTempClass()
    class RegistrationStatus(object):
        def __init__(self, type=_M_Accounts.AccountType.STANDARD, password='', manager=None):
            self.type = type
            self.password = password
            self.manager = manager

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Accounts.RegistrationStatus):
                return NotImplemented
            else:
                if self.type != other.type:
                    return False
                if self.password != other.password:
                    return False
                if self.manager != other.manager:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Accounts._t_RegistrationStatus)

        __repr__ = __str__

    _M_Accounts._t_RegistrationStatus = IcePy.defineStruct('::Accounts::RegistrationStatus', RegistrationStatus, (), (
        ('type', (), _M_Accounts._t_AccountType),
        ('password', (), IcePy._t_string),
        ('manager', (), _M_Accounts._t_AccountManagerPrx)
    ))

    _M_Accounts.RegistrationStatus = RegistrationStatus
    del RegistrationStatus

if 'AccountAccess' not in _M_Accounts.__dict__:
    _M_Accounts.AccountAccess = Ice.createTempClass()
    class AccountAccess(object):
        def __init__(self, type=_M_Accounts.AccountType.STANDARD, manager=None):
            self.type = type
            self.manager = manager

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_Accounts.AccountAccess):
                return NotImplemented
            else:
                if self.type != other.type:
                    return False
                if self.manager != other.manager:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_Accounts._t_AccountAccess)

        __repr__ = __str__

    _M_Accounts._t_AccountAccess = IcePy.defineStruct('::Accounts::AccountAccess', AccountAccess, (), (
        ('type', (), _M_Accounts._t_AccountType),
        ('manager', (), _M_Accounts._t_AccountManagerPrx)
    ))

    _M_Accounts.AccountAccess = AccountAccess
    del AccountAccess

_M_Accounts._t_BankManager = IcePy.defineValue('::Accounts::BankManager', Ice.Value, -1, (), False, True, None, ())

if 'BankManagerPrx' not in _M_Accounts.__dict__:
    _M_Accounts.BankManagerPrx = Ice.createTempClass()
    class BankManagerPrx(Ice.ObjectPrx):

        def registerNewAccount(self, fullName, PESEL, declaredMonthlyIncome, context=None):
            return _M_Accounts.BankManager._op_registerNewAccount.invoke(self, ((fullName, PESEL, declaredMonthlyIncome), context))

        def registerNewAccountAsync(self, fullName, PESEL, declaredMonthlyIncome, context=None):
            return _M_Accounts.BankManager._op_registerNewAccount.invokeAsync(self, ((fullName, PESEL, declaredMonthlyIncome), context))

        def begin_registerNewAccount(self, fullName, PESEL, declaredMonthlyIncome, _response=None, _ex=None, _sent=None, context=None):
            return _M_Accounts.BankManager._op_registerNewAccount.begin(self, ((fullName, PESEL, declaredMonthlyIncome), _response, _ex, _sent, context))

        def end_registerNewAccount(self, _r):
            return _M_Accounts.BankManager._op_registerNewAccount.end(self, _r)

        def recoverAccountAccess(self, PESEL, context=None):
            return _M_Accounts.BankManager._op_recoverAccountAccess.invoke(self, ((PESEL, ), context))

        def recoverAccountAccessAsync(self, PESEL, context=None):
            return _M_Accounts.BankManager._op_recoverAccountAccess.invokeAsync(self, ((PESEL, ), context))

        def begin_recoverAccountAccess(self, PESEL, _response=None, _ex=None, _sent=None, context=None):
            return _M_Accounts.BankManager._op_recoverAccountAccess.begin(self, ((PESEL, ), _response, _ex, _sent, context))

        def end_recoverAccountAccess(self, _r):
            return _M_Accounts.BankManager._op_recoverAccountAccess.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Accounts.BankManagerPrx.ice_checkedCast(proxy, '::Accounts::BankManager', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Accounts.BankManagerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Accounts::BankManager'
    _M_Accounts._t_BankManagerPrx = IcePy.defineProxy('::Accounts::BankManager', BankManagerPrx)

    _M_Accounts.BankManagerPrx = BankManagerPrx
    del BankManagerPrx

    _M_Accounts.BankManager = Ice.createTempClass()
    class BankManager(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Accounts::BankManager', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Accounts::BankManager'

        @staticmethod
        def ice_staticId():
            return '::Accounts::BankManager'

        def registerNewAccount(self, fullName, PESEL, declaredMonthlyIncome, current=None):
            raise NotImplementedError("servant method 'registerNewAccount' not implemented")

        def recoverAccountAccess(self, PESEL, current=None):
            raise NotImplementedError("servant method 'recoverAccountAccess' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Accounts._t_BankManagerDisp)

        __repr__ = __str__

    _M_Accounts._t_BankManagerDisp = IcePy.defineClass('::Accounts::BankManager', BankManager, (), None, ())
    BankManager._ice_type = _M_Accounts._t_BankManagerDisp

    BankManager._op_registerNewAccount = IcePy.Operation('registerNewAccount', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_double, False, 0)), (), ((), _M_Accounts._t_RegistrationStatus, False, 0), (_M_Accounts._t_PeselRegisteredException,))
    BankManager._op_recoverAccountAccess = IcePy.Operation('recoverAccountAccess', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), _M_Accounts._t_AccountAccess, False, 0), (_M_Accounts._t_AuthenticationFailedException,))

    _M_Accounts.BankManager = BankManager
    del BankManager

# End of module Accounts
